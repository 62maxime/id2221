{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<p align=\"center\"><img src=\"logo/spark.png\" alt=\"Hadoop Logo\" width=\"250\"/></p>\n",
    "# **Lab 3 - Spark Streaming**\n",
    "#### The following steps demonstrate how to create a simple Spark streaming application. In this notebook you will see how to read data stream from Kafka, make a base DStream, and appy functions to it. In this assignment, we will go through the code step by step, but you will need to complete the code as a standalone application.\n",
    "\n",
    "#### Spark Streaming is an extension of the core Spark API that enables scalable, high-throughput, fault-tolerant stream processing of live data streams. Spark Streaming provides a high-level abstraction called *discretized stream* or `DStream` that represents a continuous stream of data. `DStream`s can be created either from input data streams from sources such as Kafka, Flume, and Kinesis, or by applying high-level operations on other `DStream`s. Internally, a `DStream` is represented as a sequence of RDDs.\n",
    "\n",
    "#### Here, we use Kafka as our datasource. Apache Kafka is publish-subscribe messaging rethought as a distributed, partitioned, replicated commit log service. The data in this assignment are key-value pairs in the form of \"String,int\", and we  want to measure the average value of each key and continuously update it, while new pairs arrive. Since we use Kafka in this assignment, we first need to download and install it, and run its servers. You can download Kafka from [here](https://www.apache.org/dyn/closer.cgi?path=/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz).\n",
    "\n",
    "#### Kafka uses ZooKeeper to maintain the configuration information, so you need to first start a ZooKeeper server if you do not already have one.\n",
    "```bash\n",
    "bin/zookeeper-server-start.sh config/zookeeper.properties\n",
    "```\n",
    "#### Start the Kafka server.\n",
    "```bash\n",
    "bin/kafka-server-start.sh config/server.properties\n",
    "```\n",
    "#### Then, create a topic. A topic is a category or feed name to which messages are published. For each topic, the Kafka cluster maintains a partitioned log that looks like this. Let's create a topic named \"avg\" with a single partition and only one replica.\n",
    "```bash\n",
    "bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic avg\n",
    "```\n",
    "#### To see the list of topics you can run the following command.\n",
    "```bash\n",
    "bin/kafka-topics.sh --list --zookeeper localhost:2181\n",
    "```\n",
    "#### To generate pairs of \"String,int\" and feed them to Kafka, you are given a code in the `generator` folder. You just need to download the code, go to its folder and run the following command:\n",
    "```bash\n",
    "sbt run\n",
    "```\n",
    "#### Now, we can start to implement our code. First, we import the names of the Spark Streaming classes and some implicit conversions from `StreamingContext` into our environment. `StreamingContext` is the main entry point for all streaming functionality. We create a local `StreamingContext` with two execution threads, and a batch interval of 2 second.\n",
    "\n",
    "```scala\n",
    "import java.util.HashMap\n",
    "\n",
    "import org.apache.spark.SparkConf\n",
    "import org.apache.spark.streaming._\n",
    "import org.apache.spark.streaming.kafka._\n",
    "import org.apache.spark.storage.StorageLevel\n",
    "\n",
    "import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n",
    "import kafka.serializer.{DefaultDecoder, StringDecoder}\n",
    "\n",
    "// Create a local StreamingContext with two working thread and batch interval of 2 second\n",
    "val sparkConf = new SparkConf().setAppName(\"KafkaStreamAvg\").setMaster(<FILL IN>)\n",
    "val ssc = new StreamingContext(<FILL IN>)\n",
    "```\n",
    "#### Saving of the generated RDDs to reliable storage (data checkpointing) is necessary in some stateful transformations that combine data across multiple batches. In such transformations, the generated RDDs depend on RDDs of previous batches, which causes the length of the dependency chain to keep increasing with time. To avoid such unbounded increases in recovery time, intermediate RDDs of stateful transformations are periodically checkpointed to reliable storage (e.g., HDFS) to cut off the dependency chains. Moreover, checkpointing must be enabled for applications with stateful transformations, e.g., mapWithState. You can enable it by setting a directory in a fault-tolerant, reliable file system to which the checkpoint information will be saved. This is done by using `streamingContext.checkpoint(checkpointDirectory)`. This will allow you to use the aforementioned stateful transformations. \n",
    "```scala\n",
    "ssc.checkpoint(\"checkpoint\")\n",
    "```\n",
    "#### Spark Streaming provides two categories of built-in streaming sources: (i) basic sources, which are directly available in the `StreamingContext` API, e.g., file systems, and socket connections, and (ii) advanced sources, which are available through extra utility classes, e.g., Kafka, Flume, Kinesis, and Twitter. Here we receive data from Kafka. There are two approaches to this: (i) using receivers and Kafkaâ€™s high-level API, and (ii) without using receivers. They have different programming models, performance characteristics, and semantics guarantees, so read on for more details. \n",
    "\n",
    "#### In the receiver-based approach, the data received from Kafka through a receiver is stored in Spark executors, and then jobs launched by Spark Streaming processes the data. However, under default configuration, this approach can lose data under failures. To ensure zero-data loss, then, you have to additionally enable Write Ahead Logs (WAL) in Spark Streaming that synchronously saves all the received Kafka data into a distributed file system. To use this approach, you need to connect to Kafka through `KafkaUtils.createStream`.\n",
    "\n",
    "#### The receiver-less \"direct\" approach, instead of using receivers to receive data, periodically queries Kafka for the latest offsets in each topic+partition, and accordingly defines the offset ranges to process in each batch. When the jobs to process the data are launched, Kafka's simple consumer API is used to read the defined ranges of offsets from Kafka (similar to read files from a file system). In this apporach, you can connect to Kafka by calling `KafkaUtils.createDirectStream`.\n",
    "\n",
    "#### In both models, you need to define the Kafka parameteres, as a `Map` of configuration parameters to their values. The list of parameteres are available [here](http://kafka.apache.org/08/configuration.html).\n",
    "\n",
    "```scala\n",
    "val kafkaConf = Map(\n",
    "    \"metadata.broker.list\" -> \"localhost:9092\",\n",
    "    \"zookeeper.connect\" -> \"localhost:2181\",\n",
    "    \"group.id\" -> \"kafka-spark-streaming\",\n",
    "    \"zookeeper.connection.timeout.ms\" -> \"1000\")\n",
    "```\n",
    "\n",
    "#### Message are read from Kafka as key and values. In this application we do not make any use of the key. To be able to easily split the message into individual part we use a String type and StringDecoder for the value of the message. The value part of the messages are strings of \"String,int\", so, you need to split it by \",\" and make pairs of `(String, int)` \n",
    "\n",
    "```scala\n",
    "val messages = KafkaUtils.createStream[String, String, StringDecoder, StringDecoder](<FILL IN>)\n",
    "//or\n",
    "val messages = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](<FILL IN>)\n",
    "\n",
    "val values = messages.map(<FILL IN>)\n",
    "val pairs = values.<FILL IN>\n",
    "```\n",
    "\n",
    "#### Then, you need to measure the average of the values for receiving pairs `(String, int)`, and update the average continuesly as you receive new paris. You can use `mapWithState` with a function as its input to sum of the values for each `String` key and calculate the average.\n",
    "\n",
    "```scala\n",
    "def mappingFunc(key: String, value: Option[Double], state: State[Double]): Option[(String, Double)] = {\n",
    "    <FILL IN>\n",
    "}\n",
    "\n",
    "val stateDstream = pairs.mapWithState(<FILL IN>)\n",
    "```\n",
    "#### Note that when these lines are executed, Spark Streaming only sets up the computation it will perform when it is started, and no real processing has started yet. To start the processing after all the transformations have been setup, you need to start the computation.\n",
    "\n",
    "```scala\n",
    "stateDstream.print()\n",
    "ssc.start()\n",
    "ssc.awaitTermination()\n",
    "```\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "name": "scala",
   "version": "2.10.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
